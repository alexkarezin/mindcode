package info.teksol.mindcode.compiler.optimization;

import info.teksol.mindcode.ast.AstNodeBuilder;
import info.teksol.mindcode.compiler.instructions.LogicInstruction;
import info.teksol.mindcode.compiler.LogicInstructionPipeline;
import info.teksol.mindcode.compiler.instructions.InstructionProcessor;

import java.util.Iterator;
import java.util.List;

/**
 * Removes unnecessary case expression variable ({@code __ast}) and replaces it with the original variable containing
 * the value of the case expression. The set instruction is removed, while the other instructions (one or more jump
 * instruction per {@code when} branch) are updated to replace the {@code __ast} variable with the one used
 * in the set statement.
 * <p>
 * The optimization is performed only when the following conditions are met:
 * <ol>
 * <li>The set instruction assigns to an {@code __ast} variable.</li>
 * <li>The set instruction is the first of all those using the {@code __ast} variable (the check is based on absolute
 * instruction sequence in the program, not on the actual program flow).</li>
 * <li>Each subsequent instruction using the {@code __ast} variable conforms to the code generated by the compiler
 * (i.e. has the form of {@code jump target <condition> __astX testValue})</li>
 * </ol>
 * Push and pop instructions are ignored by the above algorithm. Push/pop instructions of any eliminated variables
 * are removed by the stack usage optimization down the line.
 */

class CaseExpressionOptimizer extends GlobalOptimizer {
    public CaseExpressionOptimizer(InstructionProcessor instructionProcessor, LogicInstructionPipeline next) {
        super(instructionProcessor, next);
    }

    @Override
    protected boolean optimizeProgram() {
        for (Iterator<LogicInstruction> it = program.iterator(); it.hasNext(); ) {
            LogicInstruction instruction = it.next();
            if (!instruction.isSet()) continue;

            String arg0 = instruction.getArgs().get(0);
            // Not an __ast variable
            if (!arg0.startsWith(AstNodeBuilder.AST_PREFIX)) continue;

            String arg1 = instruction.getArgs().get(1);
            List<LogicInstruction> list = findInstructions(ix -> ix.getArgs().contains(arg0) && !ix.isPushOrPop());
            // The set instruction is not the first one
            if (list.get(0) != instruction) continue;

            // Some of the other instructions aren't part of the case expression
            if (!list.stream().skip(1).allMatch(ix -> isStandardCaseWhenInstruction(ix, arg0))) continue;

            // Replace __ast with actual value in all case branches
            list.stream().skip(1).forEach(ix -> replaceInstruction(ix, replaceAllArgs(ix, arg0, arg1)));
            it.remove();
        }

        return false;
    }

    private boolean isStandardCaseWhenInstruction(LogicInstruction ix, String ast) {
        return ix.isJump() && ix.getArgs().get(2).equals(ast);
    }
}
