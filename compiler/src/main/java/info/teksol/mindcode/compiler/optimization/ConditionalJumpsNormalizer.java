package info.teksol.mindcode.compiler.optimization;

import info.teksol.mindcode.compiler.LogicInstructionPipeline;
import info.teksol.mindcode.compiler.instructions.InstructionProcessor;
import info.teksol.mindcode.compiler.instructions.JumpInstruction;
import info.teksol.mindcode.compiler.instructions.LogicInstruction;
import info.teksol.mindcode.logic.LogicBoolean;

import static info.teksol.mindcode.logic.LogicBoolean.FALSE;
import static info.teksol.mindcode.logic.LogicBoolean.TRUE;

/**
 * Replaces conditional jumps whose condition is always true with unconditional jumps
 * and completely removes jumps that are always false.
 * Such conditions will only be generated by explicit code, e.g. {@code if false} or {@code while true}.
 * If a variable is involved (e.g. {@code ACTIVE = false; while ACTIVE ...}) the jump won't be removed/replaced.
 */
class ConditionalJumpsNormalizer extends PipelinedOptimizer {
    public ConditionalJumpsNormalizer(InstructionProcessor instructionProcessor, LogicInstructionPipeline next) {
        super(instructionProcessor, next);
    }

    @Override
    protected State initialState() {
        return new BaseState();
    }

    private final class BaseState implements State {
        @Override
        public State emit(LogicInstruction instruction) {
            if (instruction instanceof JumpInstruction ix) {
                if (effectivelyUnconditional(ix)) {
                    emitToNext(createUnconditionalJump(ix.getTarget()));
                } else if (!alwaysFalse(ix)) {
                    emitToNext(instruction);
                }
            } else {
                emitToNext(instruction);
            }
            return this;
        }

        @Override
        public State flush() {
            return this;
        }
    }

    private boolean effectivelyUnconditional(JumpInstruction jump) {
        return switch (jump.getCondition()) {
            case EQUAL      -> hasArgs(jump, TRUE, TRUE) || hasArgs(jump, FALSE, FALSE);
            case NOT_EQUAL  -> hasArgs(jump, TRUE, FALSE) || hasArgs(jump, FALSE, TRUE);
            default         -> false;
        };
    }

    private boolean alwaysFalse(JumpInstruction jump) {
        return switch (jump.getCondition()) {
            case EQUAL      -> hasArgs(jump, TRUE, FALSE) || hasArgs(jump, FALSE, TRUE);
            case NOT_EQUAL  -> hasArgs(jump, TRUE, TRUE) || hasArgs(jump, FALSE, FALSE);
            default         -> false;
        };
    }

    private boolean hasArgs(JumpInstruction jump, LogicBoolean first, LogicBoolean second) {
        return jump.getFirstOperand().equals(first) && jump.getSecondOperand().equals(second);
    }
}
