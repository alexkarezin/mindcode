package info.teksol.mindcode.compiler.optimization;

import info.teksol.mindcode.compiler.LogicInstructionPipeline;
import info.teksol.mindcode.compiler.instructions.InstructionProcessor;
import info.teksol.mindcode.compiler.instructions.JumpInstruction;
import info.teksol.mindcode.compiler.instructions.LogicInstruction;
import info.teksol.mindcode.logic.Opcode;

/**
 * Replaces conditional jumps whose condition is always true with unconditional jumps
 * and completely removes jumps that are always false.
 * Such conditions will only be generated by explicit code, e.g. {@code if false} or {@code while true}.
 * If a variable is involved (e.g. {@code ACTIVE = false; while ACTIVE ...}) the jump won't be removed/replaced.
 */
class ConditionalJumpsNormalizer extends PipelinedOptimizer {
    public ConditionalJumpsNormalizer(InstructionProcessor instructionProcessor, LogicInstructionPipeline next) {
        super(instructionProcessor, next);
    }

    @Override
    protected State initialState() {
        return new BaseState();
    }

    private final class BaseState implements State {
        @Override
        public State emit(LogicInstruction instruction) {
            if (instruction instanceof JumpInstruction ix) {
                if (effectivelyUnconditional(ix)) {
                    emitToNext(createInstruction(Opcode.JUMP, ix.getTarget(), "always"));
                } else if (!alwaysFalse(ix)) {
                    emitToNext(instruction);
                }
            } else {
                emitToNext(instruction);
            }
            return this;
        }

        @Override
        public State flush() {
            return this;
        }
    }

    private boolean effectivelyUnconditional(JumpInstruction jump) {
        switch (jump.getCondition()) {
            case "equal":       return hasArgs(jump, "true", "true") || hasArgs(jump, "false", "false");
            case "notEqual":    return hasArgs(jump, "true", "false") || hasArgs(jump, "false", "true");
            default:            return false;
        }
    }

    private boolean alwaysFalse(JumpInstruction jump) {
        switch (jump.getCondition()) {
            case "equal":       return hasArgs(jump, "true", "false") || hasArgs(jump, "false", "true");
            case "notEqual":    return hasArgs(jump, "true", "true") || hasArgs(jump, "false", "false");
            default:            return false;
        }
    }

    private boolean hasArgs(JumpInstruction jump, String first, String second) {
        return jump.getFirstOperand().equals(first) && jump.getSecondOperand().equals(second);
    }
}
