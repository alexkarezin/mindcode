# Compiler directives

Mindcode allows you to specify some compiler parameters from the code using special `#set` commands.
Most of these options can be alternatively specified as parameters of the command line compiler.
The `#set` commands allow you to do the same from the web application.

The basic syntax is `#set option = value`. For some options, the value can actually be a comma separated list of values.

```
#set target = 7
#set DeadCodeEliminator = off 
#set DeadCodeEliminator = on (normal)
#set DeadCodeEliminator = aggressive
@set optimization = off / on / aggressive
#set volatile = none
#set instruction_limit = 1000
```

## Option `target`

Use the `target` option to specify the Mindcode version:

```
#set target = 6
```

Possible values for this option are:
* `6`: compile for Mindcode Logic version 6
* `7S`: compile for Mindcode Logic version 7 standard processors
* `7W`: compile for Mindcode Logic version 7 world processor

## Option `optimize`

Use the `optimize` option to activate or deactivate various optimizations of the code.

# Compiler optimization

Code optimization runs on compiled (ML) code. The compiled code is inspected for sequences of instructions
which can be removed or replaced by faster but equivalent ML code.

The information on compiler optimizations is a bit technical.
It might be useful if you're trying to better understand how Mindcode generates the ML code.

## Conditional jumps normalization

This optimization handles conditional jumps whose condition is constant:
* always false conditional jumps are removed,
* always true conditional jumps are converted to unconditional ones.

The first case reduces the code size and speeds up execution. The second one in itself improves neither size not speed,
but allows those jumps to be handled by other optimizations aimed at unconditional jumps to handle them.

These conditional jumps will only be generated by explicit code, e.g. `while false` or `while true`.
(Note that `if false ... end` won't even get compiled since constant expression evaluation was introduced.)
If a variable is involved (e.g. `ACTIVE = false; while ACTIVE ...`) the jump won't be removed/replaced.

## Dead code elimination

This optimization inspects the entire code and removes all instructions that write to variables,
if none of the variables written to are actually read anywhere in the code.
As a result, compiling code snippets can result in some instructions being unexpectedly removed.
Let's say you want to see how the compiler handles certain complicated expression:

```
x0 = 0.001
y0 = 0.002
x1 = x0 * x0 + y0 * y0
x2 = 2 * x0 * y0
```

and the compiler produces:

```
end
```

It's not broken -- it correctly removed code that doesn't have any effect to the rest of the program,
which, in this case, happens to be all code. When turning off dead code elimination, we get the expected code:

```
set x0 0.001
set y0 0.002
op mul __tmp0 x0 x0
op mul __tmp1 y0 y0
op add x1 __tmp0 __tmp1
op mul __tmp3 2 x0
op mul x2 __tmp3 y0
end
```

Dead code eliminator also inspects your code and lists suspicious variables:
* Unused variables: those are the variables that were eliminated.
* Uninitialized variables: those are variables that are read by the program, but never written to.
(Mindcode doesn't - yet - detects situations where variable is read before it is first written to.)

Both cases deserve closer inspection, as they might be a result of a typo in a variable name.

## Single step jump elimination

The Mindcode compiler sometimes generates sequences of unconditional jumps where each jump targets the next instruction.
This optimization finds them and removes all such jumps.

Technically, if we have a sequence
```
0: jump 2 ...
1: jump 2 ...
2: ...
```
we could eliminate both jumps. This optimization will only remove the second jump, because before that removal the first
one doesn't target the next instruction. However, such sequences aren't typically generated by the compiler.

Multiple optimization passes will handle this issue as well.

## Temporary inputs elimination

The compiler sometimes creates temporary variables whose only function is to pass value to another instruction.
This optimization removes all assignments to temporary variables that are only used as arguments
in a subsequent instruction. The `set` instruction is removed, while the other instruction is updated
to replace the temp variable with the value used in the set statement.

The optimization is performed only when the following conditions are met:
1. The `set` instruction assigns to a `__tmp` variable.
2. The `__tmp` variable is used in exactly one other instruction, which follows the `set` instruction
   (the check is based on absolute instruction sequence in the program, not on the actual program flow).
3. All arguments of the other instruction referencing the `__tmp` variable are input ones.

`push` and `pop` instructions are ignored by the above algorithm. `push`/`pop` instructions of any eliminated variables
are removed by the stack usage optimization down the line.

## Temporary outputs elimination

The compiler sometimes creates temporary variables whose only function is to store output value of an instruction before passing it somewhere else.
This optimization removes all assignments to temporary variables that carry over the output value
of the preceding instruction. The `set` instruction is removed, while the preceding instruction is updated
to replace the temp variable with the target variable used in the set statement.

The optimization is performed only when the following conditions are met:
1. The `set` instruction assigns from a `__tmp` variable.
2. The `__tmp` variable is used in exactly one other instruction. The other instruction 
   immediately precedes the instruction producing the `__tmp` variable 
3. All arguments of the other instruction referencing the `__tmp` variable are output ones.

`push` and `pop` instructions are ignored by the above algorithm. `push`/`pop` instructions of any eliminated variables
are removed by the stack usage optimization down the line.

## Case expression optimization

Case expressions allocate temporary variable to hold the value of the input expression.
This optimization removes unnecessary case expression variable (`__ast`) and replaces it with the original
variable containing the value of the case expression. The set instruction is removed, while the other instructions
are updated to replace the `__ast` variable with the one used in the set statement.

The optimization is performed only when the following conditions are met:
1. The set instruction assigns to an `__ast` variable.
2. The set instruction is the first of all those using the `__ast` variable (the check is based on absolute
   instruction sequence in the program, not on the actual program flow).
3. Each subsequent instruction using the `__ast` variable conforms to the code generated by the compiler
   (i.e. has the form of `jump target <condition> __astX testValue`)

`push` and `pop` instructions are ignored by the above algorithm. `push`/`pop` instructions of any eliminated variables
are removed by the stack usage optimization down the line.

## Conditional jump optimization

Conditional jumps are sometimes compiled into an `op` instruction evaluating a boolean expression,
and a conditional jump acting on the value of the expression.

This optimization turns the following sequence of instructions:
```
   op <comparison> var1 A B
   jump label equal var2 false
```

into

```
   jump label <inverse of comparison> A B
```

Requirements:
1. `jump` is an equal comparison to `false`
2. `var1` and `var2` are identical
3. `var1` is a `__tmp` variable
4. `<comparison>` has an inverse

## Jump over jump elimination

This optimization detects situations where a conditional jump skips a following, unconditional one and replaces it
with a single conditional jump with a reversed condition and a target of the second jump. Example:

```
jump __label0 equal __tmp9 false
jump __label1
label __label0
```

will be turned to

```
jump __label1 notEqual __tmp9 false
```

Optimization won't be done if the condition doesn't have an inverse (`strictEqual`).

These sequences of instructions may arise when using break or continue statements:

```
while true
  ...
  if not_alive
    break
  end
end
```

## Jump target propagation

If a jump (conditional or unconditional) targets an unconditional jump, the target of the first jump is redirected
to the target of the second jump, repeated until the end of jump chain is reached. Moreover:
* `end` instruction is handled identically to `jump 0 always`
* conditional jumps in the jump chain are followed if
  * their condition is identical to the condition the first jump, and
  * the condition arguments do not contain a volatile variable (`@time`, `@tick`, `@counter` etc.)

No instructions are removed or added, but the execution of the code is faster.

Note: this is a simplified form of jump threading optimization.

## Inaccessible code elimination

This optimizer removes instructions that are inaccessible.
There are several ways inaccessible instructions might appear:
1. Jump target propagation can create inaccessible jumps that are no longer targeted
2. User-created inaccessible regions, such as `while false ... end`
3. User defined functions which are called from an inaccessible region

Instruction removal is done in loops until no instructions are removed. This way entire branches
of inaccessible code (i.e. code inside the `while false ... end` statement) should be eliminated,
assuming the unconditional jump normalization optimizer was on the pipeline.

## Stack usage optimization

Optimizes the stack usage -- eliminates `push`/`pop` instruction pairs determined to be unnecessary. Several
independent optimizations are performed:

* `push`/`pop` instruction elimination for variables that are not used anywhere else (after being eliminated
  by other optimizations). The optimization is done globally, in a single pass across the entire program.
* every remaining variable pushed/popped around a function call is inspected. If the block of code between the function
  call and the end of the function is linear (doesn't contain jumps away from the code block -- function calls aren't
  considered) and the variable is not read in the code block, it is removed from the stack.

## Function parameter optimization

This optimizer eliminates unnecessary function parameters and local variables (replaces them by the argument
or value assigned to them). Significantly improves inline functions, but seldom might help with other functions
as well. The optimizer processes individual functions (inline and out-of-line) one by one and searches for 
`set` instructions assigning a value to a variable (i.e. `set target value`) and checks these preconditions are met:

1. The target variable is a local variable or parameter -- has the function prefix followed by an underscore,
   e.g. `__fn0_`. This excludes `__fnXretaddr` and `__fnXretval` variables, which must be preserved.
2. The target variable is modified exactly once, i.e. there isn't any other instruction besides the original `set`
   instruction which would modify the variable. This includes `push`/`pop` instructions, but if those are unnecessary,
   they would be already removed by prior optimizers.
3. The value being assigned to the target variable is not volatile (e.g. `@time`, `@tick`, `@counter` etc.)
   and is not modified anywhere in the function.
4. If the function contains a `call` instruction, the value is not a global variable. Global variables might be
   modified by the called function. (Block names, while technically also global, are not affected, as these are
   effectively constant.)

When the conditions are met, the following happens:
* The original instruction assigning value to the target variable is removed.
* Every remaining occurrence of target variable is replaced with the assigned value.

Functions are located in the code using the entry and exit labels marked with function prefix.

## Print merging

This optimization merges together print instructions with string literal arguments.
The print instructions will get merged even if they aren't consecutive, assuming there aren't instructions
that could break the print sequence (`jump`, `label` or `print <variable>`).

Effectively, this optimization eliminates a `print` instruction by turning this

```
println("Items: ", items)
println("Time: " @time)
```
into this:

```
print("Items: ", items)
print("\nTime: ", @time "\n")
```

This optimization can create long string constants, but according to our tests these can be passed
into Mindustry processors even if they're longer than what the Mindustry GUI allows to enter.

---

[« Previous: Functions](SYNTAX-4-FUNCTIONS.markdown)